# -*- coding: utf-8 -*-
"""Preprocesamiento y preparacion de datos R.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11SY_WMJKh2k2CRpxn-7SKvKEGJq-VkZN

Enlace de los datos: https://www.kaggle.com/datasets/fedesoriano/stroke-prediction-dataset
"""

!pip install rpy2==3.5.1

# Commented out IPython magic to ensure Python compatibility.
# %load_ext rpy2.ipython

# Commented out IPython magic to ensure Python compatibility.
# %%R
# install.packages('corrplot')

# Commented out IPython magic to ensure Python compatibility.
# %%R
# library(corrplot)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# install.packages("caret")

# Commented out IPython magic to ensure Python compatibility.
# %%R
# library(caret)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# require(tidyverse)

from  google.colab import drive

drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# %%R
# datos<-read.csv("/content/gdrive/MyDrive/Colab Notebooks/Machine Learning clase/Datos/healthcare-dataset-stroke-data.csv")

"""Según la Organización Mundial de la Salud (OMS), el accidente cerebrovascular es la segunda causa de muerte en todo el mundo, responsable de aproximadamente el 11% del total de muertes.
Este conjunto de datos se utiliza para predecir si es probable que un paciente sufra un accidente cerebrovascular en función de los parámetros de entrada como el sexo, la edad, diversas enfermedades y el tabaquismo. Cada fila de los datos proporciona información relevante sobre el paciente.

1) id: identificador único del registro.

2) gender: género de la persona a la que pertenece el registro el cual puede ser ‘Male’, ‘Female’, o ‘Other’.

3) age: corresponde con las edades de las personas, donde el promedio de las personas encuestadas es de 43 años.

4) hypertension: indica si la persona tiene hipertensión. 0 se usa para afirmar que no tiene hipertensión y 1 para afirmar que sí tiene hipertensión.

5) heart_disease: señala si las personas sufren de enfermedades cardiacas. 0 se usa para indicar que no sufre enfermedades cardíacas y 1 para indicar que sufre una enfermedad cardiaca.

6) ever_married: indica si la persona se ha casado. En este caso se usa ‘No’ o ‘Yes’.

7) work_type: indica el tipo de trabajo de la persona. Las etiquetas en este caso son ‘Never worked’, ‘Govt_Jov’, ‘Private’, ‘Self-employed’ y ‘children’.

8) Residence_type: indica el tipo de zona donde vive la persona. En este caso las etiquetas son dos: ‘Rural’ y ‘Urban’.

9) avg_glucose_level: indica el nivel de glucosa en promedio de una persona. El promedio inicial de los registro en esta variable se encuentra en 106.14 mg/dL

10) bmi:indica acerca del índice de masa corporal de una persona. El promedio de esta variable en los datos recolectados es de 28.8.

11) smoking_status: indica si la persona es fumadora o ha sido fumadora. las etiquetas de esta variable son ‘formerly smoked’, ‘never smoked’, ‘smokes’ y ‘Unknown’ (esa etiqueta se usó cuando no fue posible obtener ese dato del paciente).

12) stroke: indica si el paciente ha sufrido un accidente cerebrovascular. Se usa 1 para indicar que si lo ha sufrido y 0 para indicar que no lo ha sufrido.


"""

# Commented out IPython magic to ensure Python compatibility.
# %%R
# head(datos)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# summary(datos)

"""Par el análisis podemos dejar de lado el id por los que nuestras variables de interés corresponderan con gender,age, hypertension, heart_disease, ever_married, work_type, residence_type,avg_glucose, bmi, smoking_status, y stroke (esta última corresponda a la variable que intentamos explicar)."""

# Commented out IPython magic to ensure Python compatibility.
# %%R
# datos<-datos[,-which(names(datos)=="id")]

# Commented out IPython magic to ensure Python compatibility.
# %%R
# sum(is.na(datos$bmi))

"""Para este momento no nos encontramos con  datos vacios por lo que no será necesario borrar datos vacios para nuestro análsis."""

# Commented out IPython magic to ensure Python compatibility.
# %%R
# sapply(datos,class)

"""La función anterior la aplicamos para poder ver a cuál tipo de variable corresponden cada una de las columnas de nuestros datos. Acá identificamos que tenemos variables de tipo caracter que no nos servirán para poder realizar el análisis sin realizarles un procesamiento, por esto vamos a transformar a factor gender, ever_merried, work_type, Residence_type, smoking_satus a tipo factor y la variable bmi la transformaremos a tipo numeric.

Además de las variables anteriores vamos a transformar hypertension, heart_disease y stroke a tipo factor.

"""

# Commented out IPython magic to ensure Python compatibility.
# %%R
# datos$gender<-as.factor(datos$gender)
# datos$ever_married<-as.factor(datos$ever_married)
# datos$work_type<-as.factor(datos$work_type)
# datos$Residence_type<-as.factor(datos$Residence_type)
# datos$smoking_status<-as.factor(datos$smoking_status)
# datos$bmi<-as.numeric(datos$bmi)
# datos$hypertension<-as.factor(datos$hypertension)
# datos$heart_disease<-as.factor(datos$heart_disease)
# datos$stroke<-as.factor(datos$stroke)
#

# Commented out IPython magic to ensure Python compatibility.
# %%R
# sapply(datos,class)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# summary(datos)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# sum(is.na(datos))

# Commented out IPython magic to ensure Python compatibility.
# %%R
# datos<-na.omit(datos)

"""bmi (indice de masa corporal) estaba siendo tomado como caracter por esta razón en los campos donde no habia una dato se aceptaba como caracter N/A y por tanto no estaba vacio, pero debido a que, para realizar el análisis transformamos bmi a numérica los N/A se convirtieron en campos vacios por lo cual debemos eliminar estos valores con ***na.omit(datos)***


"""

# Commented out IPython magic to ensure Python compatibility.
# %%R
# col_f=filter(datos,stroke=="1")
# col_num=col_f[,-which(sapply(col_f,class)=="factor")]

"""Creamos otra tabla de datos que solo incluya las variables que no sean de tipo numérico y que hayan sufrido accidentes cerebrovasculares para poder observar cual es su distribución"""

# Commented out IPython magic to ensure Python compatibility.
# %%R
# 
# for (col in 1:dim(col_num)[2]){
#   var<-col_num[,col]
#   d<-density(var)
#   plot(d,main=names(col_num[col]))
#   polygon(d,col="green")
# }

"""Con el bucle recorremos las columnas de la tabla de datos y asi generamos la distribución de cada una de las variables numéricas."""

# Commented out IPython magic to ensure Python compatibility.
# %%R
# correlacion<-cor(col_num)

"""Generamos la matriz de correlación con los datos numericos, pues este método solo tiene sentido con datos numéricos o de tipo continuo."""

# Commented out IPython magic to ensure Python compatibility.
# %%R
# corrplot(correlacion,method="number",number.cex=1)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# col_fac<-datos[,-which(sapply(datos,class)=='numeric')]

# Commented out IPython magic to ensure Python compatibility.
# %%R
# head(col_fac)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# for (i in names(datos)){
#     if ((class(datos[,i])=="factor")&(i!="stroke")){
#         filtro<-filter(datos,stroke=="1")
#         plot(filtro[,i],xlab=i,ylab="count",col=50:60)
#         }
# }

"""En esta sección se creo un bucle para recorrer las columnas del conjunto de datos. Además, se creo un condicional para generar gráficos de barras para los datos que sean de tipo factor y que correspondan con registro de personas que han sufrido accidentes cerebrovasculares (por esta razón el filtro de stroke=="1"). En col dentro de pol se define un rango de colores para que las barras de las gráficas se diferencien."""

# Commented out IPython magic to ensure Python compatibility.
# %%R
# sum(is.na(datos))

# Commented out IPython magic to ensure Python compatibility.
# %%R
# summary(datos)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# ind=createDataPartition(datos$stroke,p=0.8,list=FALSE)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# train<-datos[ind,]

# Commented out IPython magic to ensure Python compatibility.
# %%R
# test<-datos[-ind,]

# Commented out IPython magic to ensure Python compatibility.
# %%R
# x_train=train[,!(names(train)%in%'stroke')]
# x_test=test[,!(names(test)%in%'stroke')]

# Commented out IPython magic to ensure Python compatibility.
# %%R
# y_train=train$stroke
# y_test=test$stroke

"""Para realizar la particion de los datos nos apoyamos de la libreria caret, en este caso decidimos usar un 80% de los datos para entrenamiento y dejar 20% para el testeo. El código createDataPartition nos genera un tipo de index de los datos de para el entrenamiento. Posterior a eso se reemplaza dentro del conunto de datos original y se asignan las variables de entrenamiento y testeo.

Para terminar se separan las variables independientes del entrenamiento y el testeo e igualmente se separa la variable objetivo que corresponde a 'stroke'.
"""